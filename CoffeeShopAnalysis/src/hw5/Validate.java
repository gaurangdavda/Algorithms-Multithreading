package hw5;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import hw5.SimulationEvent.EventType;

/**
 * @author Gaurang Davda
 */
/**
 * Validates a simulation
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() {
		}
	};

	// Helper method for validating the simulation
	private static void check(boolean check, String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			throw new InvalidSimulationException();
		}
	}

	/**
	 * Validates the given list of events is a valid simulation. Returns true if
	 * the simulation is valid, false otherwise.
	 *
	 * @param events
	 *            - a list of events generated by the simulation in the order
	 *            they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events, int numCustomers, int numCooks,
			int numTables, int machineCapacity) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with starting event");
			check(events.get(events.size() - 1).event == SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with closing event");
			check(customerOrderedBeforeEntering(events, numCustomers),
					"Customer ordered before entering the coffee shop");
			check(coffeeShopCheckCapacity(events, numTables),
					"Number of customers exceeds number of tables in the coffee shop");
			machineCapacityCheck(events, machineCapacity);
			check(customerLeftBeforeReceivingAndEating(events, numCustomers),
					"customer left the coffee shop before receiving and eating the order");
			check(customerReceivesBeforeCookCompletes(events, numCustomers),
					"customer received order before cook completed");
			check(cookTakesFoodBeforeMachineFinishesFood(events, numCustomers),
					"cook took the food before machine completes cooking it");
			check(allCustomersNotServed(events, numCustomers), "all customers were not served");
			check(cookReceivedUnplacedOrder(events), "Cook received an order before a customer placed it.");
			check(cookStartedBeforeReceiving(events), "Cook started food before cook took the order");
			check(machineStartedBeforeCookStarted(events),
					"Machine started cooking a food item before a cook started that item");
			check(machineFinishedBeforeStarting(events),
					"Machine finished a food item before the machine started that item");
			check(cookFinishesFoodsBeforeCompletesOrder(events),
					"Cook finished an order before the cook finished all the food in that order");
			return true;
		} catch (InvalidSimulationException ise) {
			ise.printStackTrace();
			return false;
		}
	}

	private static boolean coffeeShopCheckCapacity(List<SimulationEvent> events, int numTables) {
		boolean result = true;
		int currNumCustomers = 0;
		// Max Customers Test
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.CustomerEnteredCoffeeShop) {
				currNumCustomers++;
			}
			if (e.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
				currNumCustomers--;
			}
			if (currNumCustomers > numTables) {
				result = false;
			}
		}
		return result;
	}

	private static void machineCapacityCheck(List<SimulationEvent> events, int machineCapacity)
			throws InvalidSimulationException {
		boolean resultBurgers = true;
		int currNumBurgers = 0;
		boolean resultFries = true;
		int currNumFries = 0;
		boolean resultCoffees = true;
		int currNumCoffees = 0;
		// Machine Capacity Test
		for (SimulationEvent e : events) {
			if (e.event == SimulationEvent.EventType.MachineStartingFood) {
				if (e.machine.machineName.equals("grill")) {
					currNumBurgers++;
				} else if (e.machine.machineName.equals("burner")) {
					currNumFries++;
				} else if (e.machine.machineName.equals("braun")) {
					currNumCoffees++;
				}
			}
			if (e.event == SimulationEvent.EventType.MachineDoneFood) {
				if (e.machine.machineName.equals("grill")) {
					currNumBurgers--;
				} else if (e.machine.machineName.equals("burner")) {
					currNumFries--;
				} else if (e.machine.machineName.equals("braun")) {
					currNumCoffees--;
				}
			}
			if (currNumBurgers > machineCapacity) {
				resultBurgers = false;
			}
			if (currNumFries > machineCapacity) {
				resultFries = false;
			}
			if (currNumCoffees > machineCapacity) {
				resultCoffees = false;
			}
		}
		check(resultBurgers, "Exceeded grill capacity");
		check(resultFries, "Exceeded burner capacity");
		check(resultCoffees, "Exceeded braun capacity");
	}

	private static boolean customerOrderedBeforeEntering(List<SimulationEvent> events, int numCustomers) {
		boolean[] customerEntered = new boolean[numCustomers];
		boolean[] customerPlacedOrder = new boolean[numCustomers];
		boolean result = true;
		for (SimulationEvent e : events) {
			if (e.event == EventType.CustomerEnteredCoffeeShop) {
				String name = e.customer.toString();
				int custNum = Integer.parseInt(name.substring(9));
				customerEntered[custNum] = true;
			}
			if (e.event == EventType.CustomerPlacedOrder) {
				String name = e.customer.toString();
				int custNum = Integer.parseInt(name.substring(9));
				customerPlacedOrder[custNum] = true;
				if (customerPlacedOrder[custNum] && !customerEntered[custNum]) {
					result = false;
				}
			}
		}
		return result;
	}

	private static boolean cookTakesFoodBeforeMachineFinishesFood(List<SimulationEvent> events, int numOrders) {
		int numBurgersFinished = 0;
		int numBurgersTaken = 0;
		int numFriesFinished = 0;
		int numFriesTaken = 0;
		int numCoffeesFinished = 0;
		int numCoffeesTaken = 0;
		boolean result = true;
		for (SimulationEvent e : events) {
			if (e.event == EventType.CookFinishedFood) {
				if (e.food == FoodType.burger) {
					numBurgersTaken++;
				} else if (e.food == FoodType.fries) {
					numFriesTaken++;
				} else if (e.food == FoodType.coffee) {
					numCoffeesTaken++;
				}
				if (numBurgersTaken > numBurgersFinished || numFriesTaken > numFriesFinished
						|| numCoffeesTaken > numCoffeesFinished) {
					result = false;
					break;
				}
			} else if (e.event == EventType.MachineDoneFood) {
				if (e.food == FoodType.burger) {
					numBurgersFinished++;
				} else if (e.food == FoodType.fries) {
					numFriesFinished++;
				} else if (e.food == FoodType.coffee) {
					numCoffeesFinished++;
				} else {
					throw new IllegalStateException("Invalid machine name: " + e.machine.machineName);
				}
			}
		}
		return result;
	}

	private static boolean customerReceivesBeforeCookCompletes(List<SimulationEvent> events, int numOrders) {
		boolean[] customerReceived = new boolean[numOrders];
		boolean[] cookCompleted = new boolean[numOrders];
		boolean result = true;
		for (SimulationEvent e : events) {
			if (e.event == EventType.CookCompletedOrder) {
				int order = e.orderNumber;
				cookCompleted[order] = true;
			}
			if (e.event == EventType.CustomerReceivedOrder) {
				int order = e.orderNumber;
				customerReceived[order] = true;
				if (customerReceived[order] && !cookCompleted[order]) {
					result = false;
				}
			}
		}
		return result;
	}

	private static boolean customerLeftBeforeReceivingAndEating(List<SimulationEvent> events, int numCustomers) {
		boolean[] customerReceived = new boolean[numCustomers];
		boolean[] customerLeft = new boolean[numCustomers];
		boolean result = true;
		for (SimulationEvent e : events) {
			if (e.event == EventType.CustomerReceivedOrder) {
				String name = e.customer.toString();
				int custNum = Integer.parseInt(name.substring(9));
				customerReceived[custNum] = true;
			}
			if (e.event == EventType.CustomerLeavingCoffeeShop) {
				String name = e.customer.toString();
				int custNum = Integer.parseInt(name.substring(9));
				customerLeft[custNum] = true;
				if (customerLeft[custNum] && !customerReceived[custNum]) {
					result = false;
				}
			}
		}
		return result;
	}

	private static boolean allCustomersNotServed(List<SimulationEvent> events, int numCustomers) {
		boolean result = true;
		boolean[] customerServed = new boolean[numCustomers];
		for (SimulationEvent e : events) {
			if (e.event == EventType.CustomerLeavingCoffeeShop) {
				String name = e.customer.toString();
				int custNum = Integer.parseInt(name.substring(9));
				customerServed[custNum] = true;
			}
		}
		for (boolean served : customerServed) {
			if (!served) {
				result = false;
				break;
			}
		}
		return result;
	}

	private static boolean cookReceivedUnplacedOrder(List<SimulationEvent> events) {
		List<Integer> received = new ArrayList<Integer>();
		List<Integer> placed = new ArrayList<Integer>();
		boolean result = true;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CookReceivedOrder) {
				received.add(event.orderNumber);
			}
			if (event.event == SimulationEvent.EventType.CustomerPlacedOrder) {
				placed.add(event.orderNumber);
			}
			if (received.size() > placed.size()) {
				result = false;
			}
		}
		return result;
	}

	private static boolean cookStartedBeforeReceiving(List<SimulationEvent> events) {
		HashSet<Integer> set = new HashSet<Integer>();
		boolean result = true;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CookReceivedOrder) {
				set.add(event.orderNumber);
			}
			if (event.event == SimulationEvent.EventType.CookStartedFood) {
				if (!set.contains(event.orderNumber)) {
					result = false;
				}
			}

		}
		return result;
	}

	private static boolean machineStartedBeforeCookStarted(List<SimulationEvent> events) {
		boolean result = true;

		int numBurgers = 0;
		int numFries = 0;
		int numCoffee = 0;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CookStartedFood) {
				if (event.food == FoodType.burger) {
					numBurgers++;
				}
				if (event.food == FoodType.fries) {
					numFries++;
				}
				if (event.food == FoodType.coffee) {
					numCoffee++;
				}
			}
			if (event.event == SimulationEvent.EventType.MachineStartingFood) {
				if (event.food == FoodType.burger) {
					numBurgers--;
				}
				if (event.food == FoodType.fries) {
					numFries--;
				}
				if (event.food == FoodType.coffee) {
					numCoffee--;
				}
			}

			if (numBurgers < 0 || numFries < 0 || numCoffee < 0) {
				result = false;
			}
		}
		return result;
	}

	private static boolean machineFinishedBeforeStarting(List<SimulationEvent> events) {
		boolean result = true;

		int numBurgers = 0;
		int numFries = 0;
		int numCoffee = 0;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.MachineStartingFood) {
				if (event.food == FoodType.burger) {
					numBurgers++;
				}
				if (event.food == FoodType.fries) {
					numFries++;
				}
				if (event.food == FoodType.coffee) {
					numCoffee++;
				}
			}
			if (event.event == SimulationEvent.EventType.MachineDoneFood) {
				if (event.food == FoodType.burger) {
					numBurgers--;
				}
				if (event.food == FoodType.fries) {
					numFries--;
				}
				if (event.food == FoodType.coffee) {
					numCoffee--;
				}
			}

			if (numBurgers < 0 || numFries < 0 || numCoffee < 0) {
				result = false;
			}
		}
		return result;
	}

	private static boolean cookFinishesFoodsBeforeCompletesOrder(List<SimulationEvent> events) {
		boolean result = true;
		HashSet<Integer> set = new HashSet<Integer>();

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CookCompletedOrder) {
				set.add(event.orderNumber);
			}
			if (event.event == SimulationEvent.EventType.CookFinishedFood) {
				if (set.contains(event.orderNumber)) {
					result = false;
				}
			}
		}
		return result;
	}
}
